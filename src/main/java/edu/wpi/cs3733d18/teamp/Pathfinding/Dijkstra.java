package edu.wpi.cs3733d18.teamp.Pathfinding;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Stack;
import java.util.Vector;

public class Dijkstra extends Pathfinder{

    /**
     * getChildren takes a node and returns the nodes it is connected to
     * @param root
     * @return ArrayList<Node> the list of nodes that is connected to the root node with an edge
     */

    // Takes in a node and returns the nodes it is connected to
    public ArrayList <Node> getChildren(Node root) {

        ArrayList<Edge> edges = new ArrayList<>();
        ArrayList<Node> children = new ArrayList<>();

        edges = root.getEdges();
        for (Edge e : edges) {
            Node nextNode;
            if (e.getStart() == root) {
                nextNode = e.getEnd();
                    children.add(nextNode);
            } else {
                nextNode = e.getStart();
                children.add(nextNode);
            }
        }
        return children;
    }


    /**
     *
     * @param strNode start node
     * @param destNode destination node
     * @return Arraylist<Node> the path generated by the algorithm
     */
    // Dijkstra's algorithm to find shortest path from s to all other nodes
    public void findPath (Node strNode, Node destNode) {

        HashMap<Node, Double> dist = new HashMap<>();  // shortest known distance from "s"
        ArrayList<Node> visited = new ArrayList<>(); // all false initially
        ArrayList<Node> children;
        Vector<Node> queue = new Vector<>();

        dist.put(strNode, 0.0);
        queue.add(strNode);
        Node currentNode;

        if (!destNode.equals(strNode)) {
            while (!queue.isEmpty()) {
                currentNode = queue.firstElement();
                queue.remove(currentNode);
                if (!visited.contains(currentNode)) {
                    if (currentNode.equals(destNode)) {
                        return;
                    }
                    visited.add(currentNode);

                    children = getChildren(currentNode);
                    // check if the node has no children
                    //iterate through the children nodes
                    for (Node n : children) {
                        if (!dist.containsKey(n)) {
                            Edge e = n.getEdge(currentNode);
                            // calculate the weight depending on the parent node
                            double weight = e.getWeight() + dist.get(currentNode);
                            n.setParent(currentNode);
                            dist.put(n, weight);
                            queue.add(n);
                        } else {
                            // calculate the weight depending on the parent node
                            double weight = n.getEdge(currentNode).getWeight() + dist.get(currentNode);
                            if (weight < dist.get(n)) {
                                n.setParent(currentNode);
                                dist.put(n, weight);
                            }
                        }
                    }

                }
            }
        }
        return;
    }
}
